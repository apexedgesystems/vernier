# ==============================================================================
# tools/CMakeLists.txt - CLI tools (C++, Rust, Python)
#
# Discovers and builds tool subdirectories by their native toolchains:
#   cpp/   - Standard CMake (add_subdirectory)
#   rust/  - Cargo (requires cargo on PATH)
#   py/    - Poetry + pip (requires poetry and pip on PATH)
#
# Each section is gated on the directory existing and the toolchain being
# available. Safe to copy to any project that follows the same layout.
# ==============================================================================

# ------------------------------------------------------------------------------
# Helper script (generated at configure time)
# ------------------------------------------------------------------------------
# Appends PATH/PYTHONPATH entries to the build .env file (idempotent).

set(_ENV_FILE "${CMAKE_BINARY_DIR}/.env")
set(_ENV_HELPER "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-env-helper.sh")

file(
  WRITE "${_ENV_HELPER}"
  "#!/bin/bash\n"
  "# Auto-generated by ${PROJECT_NAME} tools/CMakeLists.txt\n"
  "ENV_FILE=\"${_ENV_FILE}\"\n"
  "add_if_missing() {\n"
  "  local key=\"$1\" line=\"$2\"\n"
  "  grep -q \"$key\" \"$ENV_FILE\" 2>/dev/null || printf '%s\\n' \"$line\" >> \"$ENV_FILE\"\n"
  "}\n"
  "add_if_missing 'bin/tools/rust' 'export PATH=\"\\$PWD/bin/tools/rust:\\$PATH\"'\n"
  "add_if_missing 'bin/tools/py' 'export PATH=\"\\$PWD/bin/tools/py:\\$PATH\"'\n"
  "add_if_missing 'PYTHONPATH.*lib/python' 'export PYTHONPATH=\"\\$PWD/lib/python:\\$PYTHONPATH\"'\n"
)

# ------------------------------------------------------------------------------
# C++ tools
# ------------------------------------------------------------------------------

if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cpp/CMakeLists.txt")
  add_subdirectory(cpp)
endif ()

# ------------------------------------------------------------------------------
# Rust tools
# ------------------------------------------------------------------------------

if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/rust/Cargo.toml")
  find_program(CARGO_EXECUTABLE cargo)

  if (CARGO_EXECUTABLE)
    set(_RUST_SRC "${CMAKE_CURRENT_SOURCE_DIR}/rust")
    set(_RUST_OUT "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/tools/rust")
    set(_CARGO_HOME "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-rust-cargo")
    set(_CARGO_TARGET "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-rust-target")
    set(_RUST_STAMP "${_RUST_OUT}/.built")

    # Auto-enable cuda feature if nvcc is available
    set(_CARGO_FEATURES "")
    find_program(_NVCC_EXE nvcc)
    if (_NVCC_EXE)
      set(_CARGO_FEATURES "--features cuda")
    endif ()

    # Generate build script (copies all cargo binaries)
    set(_RUST_BUILD_SCRIPT "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-build-rust-tools.sh")
    file(
      WRITE "${_RUST_BUILD_SCRIPT}"
      "#!/bin/bash\nset -e\n"
      "CARGO_HOME='${_CARGO_HOME}' '${CARGO_EXECUTABLE}' build --release"
      " --manifest-path '${_RUST_SRC}/Cargo.toml' --target-dir '${_CARGO_TARGET}'"
      " ${_CARGO_FEATURES}\n"
      "mkdir -p '${_RUST_OUT}'\n"
      "find '${_CARGO_TARGET}/release' -maxdepth 1 -type f -executable ! -name '*.*'"
      " -exec cp -f {} '${_RUST_OUT}/' \\;\n"
      "touch '${_RUST_STAMP}'\n"
    )

    add_custom_command(
      OUTPUT "${_RUST_STAMP}"
      COMMAND bash "${_RUST_BUILD_SCRIPT}"
      COMMAND bash "${_ENV_HELPER}"
      COMMENT "Building ${PROJECT_NAME} Rust tools"
      VERBATIM
    )

    add_custom_target(${PROJECT_NAME}_rust_tools DEPENDS "${_RUST_STAMP}")
    list(APPEND _TOOLS_DEPS ${PROJECT_NAME}_rust_tools)
  else ()
    message(WARNING "${PROJECT_NAME}: cargo not found -- Rust tools skipped")
  endif ()
endif ()

# ------------------------------------------------------------------------------
# Python tools
# ------------------------------------------------------------------------------

if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/py/pyproject.toml")
  find_program(POETRY_EXECUTABLE poetry)
  find_program(PIP_EXECUTABLE pip3 pip)

  if (POETRY_EXECUTABLE AND PIP_EXECUTABLE)
    set(_PY_SRC "${CMAKE_CURRENT_SOURCE_DIR}/py")
    set(_PY_OUT "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/tools/py")
    set(_PY_LIB "${CMAKE_BINARY_DIR}/lib/python")
    set(_PY_WHEELS "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-wheels")
    set(_PY_STAMP "${_PY_OUT}/.built")

    # Generate build script (handles shell globs that VERBATIM mode cannot expand)
    set(_PY_BUILD_SCRIPT "${CMAKE_BINARY_DIR}/${PROJECT_NAME}-build-py-tools.sh")
    file(
      WRITE "${_PY_BUILD_SCRIPT}"
      "#!/bin/bash\nset -e\n"
      "mkdir -p '${_PY_OUT}' '${_PY_LIB}' '${_PY_WHEELS}'\n"
      "cd '${_PY_SRC}'\n"
      "'${POETRY_EXECUTABLE}' build --format wheel --output '${_PY_WHEELS}'\n"
      "'${PIP_EXECUTABLE}' install --quiet --no-deps --target '${_PY_LIB}' --upgrade ${_PY_WHEELS}/*.whl\n"
      "rm -rf '${_PY_OUT}'\n"
      "mv '${_PY_LIB}/bin' '${_PY_OUT}'\n"
      "'${PIP_EXECUTABLE}' install --quiet --target '${_PY_LIB}' --upgrade ${_PY_WHEELS}/*.whl\n"
      "rm -rf '${_PY_LIB}/bin'\n"
      "touch '${_PY_STAMP}'\n"
    )

    add_custom_command(
      OUTPUT "${_PY_STAMP}"
      COMMAND bash "${_PY_BUILD_SCRIPT}"
      COMMAND bash "${_ENV_HELPER}"
      COMMENT "Building ${PROJECT_NAME} Python tools"
      VERBATIM
    )

    add_custom_target(${PROJECT_NAME}_py_tools DEPENDS "${_PY_STAMP}")
    list(APPEND _TOOLS_DEPS ${PROJECT_NAME}_py_tools)
  else ()
    message(WARNING "${PROJECT_NAME}: poetry/pip not found -- Python tools skipped")
  endif ()
endif ()

# ------------------------------------------------------------------------------
# Aggregate target
# ------------------------------------------------------------------------------

if (_TOOLS_DEPS)
  add_custom_target(${PROJECT_NAME}_tools ALL DEPENDS ${_TOOLS_DEPS})
endif ()
